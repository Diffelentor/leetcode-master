```
struct TreeNode {

      int val;

      TreeNode *left;

      TreeNode *right;

      TreeNode() : val(0), left(nullptr), right(nullptr) {}

      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

  };
```

# 前序、中序、后序遍历

## 递归遍历
```CPP
void inorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}

void preorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}

void postorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

## 迭代遍历

```CPP

vector<int> inorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	TreeNode* cur = root;
	while (cur != NULL || !st.empty()) {
		if (cur != NULL) { // 指针来访问节点，访问到最底层
			st.push(cur); // 将访问的节点放进栈
			cur = cur->left;                // 左
		} else {
			cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
			st.pop();
			result.push_back(cur->val);     // 中
			cur = cur->right;               // 右
		}
	}
	return result;
}

vector<int> preorderTraversal(TreeNode* root) {
	stack<TreeNode*> st;
	vector<int> result;
	if (root == NULL) return result;
	st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();                       // 中
		st.pop();
		result.push_back(node->val);
		if (node->right) st.push(node->right);           // 右（空节点不入栈）
		if (node->left) st.push(node->left);             // 左（空节点不入栈）
	}
	return result;
}

vector<int> postorderTraversal(TreeNode* root) {
	stack<TreeNode*> st;
	vector<int> result;
	if (root == NULL) return result;
	st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		st.pop();
		result.push_back(node->val);
		if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
		if (node->right) st.push(node->right); // 空节点不入栈
	}
	reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
	return result;
}
```


## 迭代遍历（空指针标记法）
```CPP
vector<int> inorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
			if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

			st.push(node);                          // 添加中节点
			st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

			if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
		} else { // 只有遇到空节点的时候，才将下一个节点放进结果集
			st.pop();           // 将空节点弹出
			node = st.top();    // 重新取出栈中元素
			st.pop();
			result.push_back(node->val); // 加入到结果集
		}
	}
	return result;
}

vector<int> preorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop();
			if (node->right) st.push(node->right);  // 右
			if (node->left) st.push(node->left);    // 左
			st.push(node);                          // 中
			st.push(NULL);
		} else {
			st.pop();
			node = st.top();
			st.pop();
			result.push_back(node->val);
		}
	}
	return result;
}

vector<int> postorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop();
			st.push(node);                          // 中
			st.push(NULL);

			if (node->right) st.push(node->right);  // 右
			if (node->left) st.push(node->left);    // 左

		} else {
			st.pop();
			node = st.top();
			st.pop();
			result.push_back(node->val);
		}
	}
	return result;
}
```

# 102.二叉树的层序遍历

[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**题解**：
队列或者递归，但都要标记层数



```CPP
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

```CPP
# 递归法
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth)
    {
        if (cur == nullptr) return;
        if (result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth + 1);
        order(cur->right, result, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

## 107.二叉树的层次遍历 II

[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**题解**：反转数组即可

## 199.二叉树的右视图

[力扣题目链接](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
**题解**：每层返回最后一个数即可

## 637.二叉树的层平均值

[力扣题目链接](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
**题解**：pass

## 429.N叉树的层序遍历

[力扣题目链接](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

**题解**：
```CPP
res.push(move(res_i))\\可以加快速度，但会清空res_i的值，即从复制变为移动（改变指针的所有权）
```

## 515.在每个树行中找最大值

[力扣题目链接](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

您需要在二叉树的每一行中找到最大的值。

**题解**：
无穷大无穷小
```CPP
int maxValue=INT_MIN;

int maxValue=numeric_limits<int>::min();
```

## 116.填充每个节点的下一个右侧节点指针

[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```cpp
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

**题解**：
pass


## 117.填充每个节点的下一个右侧节点指针II

[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

### 思路

这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑一样的味道

## 104.二叉树的最大深度

[力扣题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

## 111.二叉树的最小深度

[力扣题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

# 226.翻转二叉树

[力扣题目链接](https://leetcode.cn/problems/invert-binary-tree/)

翻转一棵二叉树。

**题解**：
按层全部翻转一次即可


# 101. 对称二叉树

[力扣题目链接](https://leetcode.cn/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

```CPP
que.push(leftNode->left);   // 加入左节点左孩子
que.push(rightNode->right); // 加入右节点右孩子
que.push(leftNode->right);  // 加入左节点右孩子
que.push(rightNode->left);  // 加入右节点左孩子
```

* [100.相同的树](https://leetcode.cn/problems/same-tree/)
* [572.另一个树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)
572代码

```CPP
class Solution {

public:

    void getString(TreeNode* root, vector<int>& rstring, int lNull, int rNull){

        if(!root){

            return;

        }

        else{

            rstring.push_back(root->val);

        }

        if(root->left){

            getString(root->left, rstring, lNull, rNull);

        }

        else{

            rstring.push_back(lNull);

        }

        if(root->right){

            getString(root->right, rstring, lNull, rNull);

        }

        else{

            rstring.push_back(rNull);

        }

  

    }

  

    bool kmp(vector<int> rstring, vector<int> sstring){

        vector<int> next(sstring.size());

        int j=0;

        next[0]=0;

        for(int i=1;i<sstring.size();i++){

            while(j>0 && sstring[j]!=sstring[i]){

                j=next[j-1];//匹配next[j-1]，若j-1和i还是匹配不上再匹配next[j-1]直到能匹配上为止

            }

            if(sstring[j]==sstring[i]){

                j++;

            }

            next[i]=j;//可以从j开始匹配但不确定能不能匹配上，也许j并不能匹配上，但j-1肯定能匹配上

        }

        j=0;

        for(int i=0;i<rstring.size();i++){

            while(j>0 && sstring[j]!=rstring[i]){

                j=next[j-1];

            }

            if(sstring[j]==rstring[i]){

                j++;

            }

            if(j==sstring.size()){

                return true;

            }

        }

        return false;

    }

  

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {

        vector<int> rstring,sstring;

        int lNull=1e4+1,rNull=1e4+2;

        getString(root, rstring, lNull, rNull);

        getString(subRoot, sstring, lNull, rNull);

        for(int i=0;i<rstring.size();i++){

            cout<<rstring[i]<<" ";

        }

        cout<<endl;

        for(int i=0;i<sstring.size();i++){

            cout<<sstring[i]<<" ";

        }

        cout<<endl;

        return kmp(rstring, sstring);

    }

};
```