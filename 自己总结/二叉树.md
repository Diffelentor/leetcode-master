```
struct TreeNode {

      int val;

      TreeNode *left;

      TreeNode *right;

      TreeNode() : val(0), left(nullptr), right(nullptr) {}

      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

  };
```

# 前序、中序、后序遍历

## 递归遍历
```CPP
void inorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}

void preorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}

void postorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

## 迭代遍历

```CPP

vector<int> inorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	TreeNode* cur = root;
	while (cur != NULL || !st.empty()) {
		if (cur != NULL) { // 指针来访问节点，访问到最底层
			st.push(cur); // 将访问的节点放进栈
			cur = cur->left;                // 左
		} else {
			cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
			st.pop();
			result.push_back(cur->val);     // 中
			cur = cur->right;               // 右
		}
	}
	return result;
}

vector<int> preorderTraversal(TreeNode* root) {
	stack<TreeNode*> st;
	vector<int> result;
	if (root == NULL) return result;
	st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();                       // 中
		st.pop();
		result.push_back(node->val);
		if (node->right) st.push(node->right);           // 右（空节点不入栈）
		if (node->left) st.push(node->left);             // 左（空节点不入栈）
	}
	return result;
}

vector<int> postorderTraversal(TreeNode* root) {
	stack<TreeNode*> st;
	vector<int> result;
	if (root == NULL) return result;
	st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		st.pop();
		result.push_back(node->val);
		if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
		if (node->right) st.push(node->right); // 空节点不入栈
	}
	reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
	return result;
}
```


## 迭代遍历（空指针标记法）
```CPP
vector<int> inorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
			if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

			st.push(node);                          // 添加中节点
			st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

			if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
		} else { // 只有遇到空节点的时候，才将下一个节点放进结果集
			st.pop();           // 将空节点弹出
			node = st.top();    // 重新取出栈中元素
			st.pop();
			result.push_back(node->val); // 加入到结果集
		}
	}
	return result;
}

vector<int> preorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop();
			if (node->right) st.push(node->right);  // 右
			if (node->left) st.push(node->left);    // 左
			st.push(node);                          // 中
			st.push(NULL);
		} else {
			st.pop();
			node = st.top();
			st.pop();
			result.push_back(node->val);
		}
	}
	return result;
}

vector<int> postorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop();
			st.push(node);                          // 中
			st.push(NULL);

			if (node->right) st.push(node->right);  // 右
			if (node->left) st.push(node->left);    // 左

		} else {
			st.pop();
			node = st.top();
			st.pop();
			result.push_back(node->val);
		}
	}
	return result;
}
```

# 102.二叉树的层序遍历

[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**题解**：
队列或者递归，但都要标记层数



```CPP
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

```CPP
# 递归法
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth)
    {
        if (cur == nullptr) return;
        if (result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth + 1);
        order(cur->right, result, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

## 107.二叉树的层次遍历 II

[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**题解**：反转数组即可

## 199.二叉树的右视图

[力扣题目链接](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
**题解**：每层返回最后一个数即可

## 637.二叉树的层平均值

[力扣题目链接](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
**题解**：pass

## 429.N叉树的层序遍历

[力扣题目链接](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

**题解**：
```CPP
res.push(move(res_i))\\可以加快速度，但会清空res_i的值，即从复制变为移动（改变指针的所有权）
```

## 515.在每个树行中找最大值

[力扣题目链接](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

您需要在二叉树的每一行中找到最大的值。

**题解**：
无穷大无穷小
```CPP
int maxValue=INT_MIN;

int maxValue=numeric_limits<int>::min();
```

## 116.填充每个节点的下一个右侧节点指针

[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```cpp
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

**题解**：
pass


## 117.填充每个节点的下一个右侧节点指针II

[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

### 思路

这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑一样的味道

## 104.二叉树的最大深度

[力扣题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

## 111.二叉树的最小深度

[力扣题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

# 226.翻转二叉树

[力扣题目链接](https://leetcode.cn/problems/invert-binary-tree/)

翻转一棵二叉树。

**题解**：
按层全部翻转一次即可


# 101. 对称二叉树

[力扣题目链接](https://leetcode.cn/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

```CPP
que.push(leftNode->left);   // 加入左节点左孩子
que.push(rightNode->right); // 加入右节点右孩子
que.push(leftNode->right);  // 加入左节点右孩子
que.push(rightNode->left);  // 加入右节点左孩子
```

* [100.相同的树](https://leetcode.cn/problems/same-tree/)
* [572.另一个树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)
## 572.另一个树的子树

### 方法一：二叉树前序+KMP
```CPP
class Solution {

public:

    void getString(TreeNode* root, vector<int>& rstring, int lNull, int rNull){

        if(!root){

            return;

        }

        else{

            rstring.push_back(root->val);

        }

        if(root->left){

            getString(root->left, rstring, lNull, rNull);

        }

        else{

            rstring.push_back(lNull);

        }

        if(root->right){

            getString(root->right, rstring, lNull, rNull);

        }

        else{

            rstring.push_back(rNull);

        }

  

    }

  

    bool kmp(vector<int> rstring, vector<int> sstring){

        vector<int> next(sstring.size());

        int j=0;

        next[0]=0;

        for(int i=1;i<sstring.size();i++){

            while(j>0 && sstring[j]!=sstring[i]){

                j=next[j-1];//匹配next[j-1]，若j-1和i还是匹配不上再匹配next[j-1]直到能匹配上为止

            }

            if(sstring[j]==sstring[i]){

                j++;

            }

            next[i]=j;//可以从j开始匹配但不确定能不能匹配上，也许j并不能匹配上，但j-1肯定能匹配上

        }

        j=0;

        for(int i=0;i<rstring.size();i++){

            while(j>0 && sstring[j]!=rstring[i]){

                j=next[j-1];

            }

            if(sstring[j]==rstring[i]){

                j++;

            }

            if(j==sstring.size()){

                return true;

            }

        }

        return false;

    }

  

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {

        vector<int> rstring,sstring;

        int lNull=1e4+1,rNull=1e4+2;

        getString(root, rstring, lNull, rNull);

        getString(subRoot, sstring, lNull, rNull);

        for(int i=0;i<rstring.size();i++){

            cout<<rstring[i]<<" ";

        }

        cout<<endl;

        for(int i=0;i<sstring.size();i++){

            cout<<sstring[i]<<" ";

        }

        cout<<endl;

        return kmp(rstring, sstring);

    }

};
```

### 方法二：数哈希匹配
模板（任意树的哈希）
```cpp
#include <bits/stdc++.h>

using namespace std;

  

using ull = unsigned long long;

const ull mask =

mt19937_64(chrono::steady_clock::now().time_since_epoch().count())();

const int MAX_N = 1e6 + 5;

  

ull h[MAX_N];

vector<vector<int>> edge(MAX_N);

set<ull> tree;

  

ull xor_shift(ull x) { // 哈希函数，使用XOR_SHIFT进行哈希，背下来就好

x ^= mask;

x ^= x << 13;

x ^= x >> 7;

x ^= x << 17;

x ^= mask;

return x;

}

  

void gethash(int root, int fa) {

h[root] = 1;

// cout << "当前节点: " << root << endl;

for (int son : edge[root]) {

if (son == fa) {

continue;

}

gethash(son, root);

h[root] += xor_shift(

h[son]); // 哈希的公式是hash[i]=i.val(没有val就用1替代)+sum(hash[i.son])

}

tree.insert(h[root]);

}

  

int main() {

cin.tie(nullptr)->sync_with_stdio(false);

int n, x, y;

cin >> n;

for (int i = 0; i < n - 1; i++) {

cin >> x >> y;

// cout << x << y << endl;

edge[x].push_back(y);

edge[y].push_back(x);

}

// cout << "开始哈希" << endl;

gethash(1, 0);

cout << tree.size();

return 0;

}
```

该题题解：
```cpp
class Solution {

public:

    using ull= unsigned long long;

    const ull mask[2]={mt19937_64(0)(),mt19937_64(1)()};//设计两个mask来应对不同子树的哈希

    vector<ull> h;

    ull shift(ull x, int i){

        x^=mask[i];

        x^=x<<13;

        x^=x>>7;

        x^=x<<17;

        x^=mask[i];

        return x;

    }

  

    ull getHash(TreeNode* root, bool is_root){

        ull hash=shift(root->val,0);//哈希的公式为hash[i]=shift(i.val)(这个shift可不加)+sum(hash[i.sons])

        if(root->left){

            hash+=shift(getHash(root->left, is_root),0);

        }

        if(root->right){

            hash+=shift(getHash(root->right, is_root),1);

        }

        if(is_root) h.push_back(hash);

        return hash;

    }

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {

        getHash(root,1);

        ull subRoot_hash=getHash(subRoot,0);

        for(ull i:h){

            if(subRoot_hash==i)return true;

        }

        return false;

    }

};
```

# 222.完全二叉树的节点个数

[力扣题目链接](https://leetcode.cn/problems/count-complete-tree-nodes/)

给出一个完全二叉树，求出该树的节点个数。

示例 1：
* 输入：root = [1,2,3,4,5,6]
* 输出：6

示例 2：
* 输入：root = []
* 输出：0

示例 3：
* 输入：root = [1]
* 输出：1

提示：

* 树中节点的数目范围是[0, 5 * 10^4]
* 0 <= Node.val <= 5 * 10^4
* 题目数据保证输入的树是 完全二叉树



# 110.平衡二叉树

[力扣题目链接](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

![110.平衡二叉树](https://file1.kamacoder.com/i/algo/2021020315542230.png)

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

![110.平衡二叉树1](https://file1.kamacoder.com/i/algo/20210203155447919.png)

返回 false 。

题解：
如果第 k 个节点位于第 h 层，则 k 的二进制表示包含 h+1 位，其中最高位是 1，其余各位从高到低表示从根节点到第 k 个节点的路径，0 表示移动到左子节点，1 表示移动到右子节点。

然后通过二分法判断最后一层存在的最右边的数

```cpp
class Solution {

public:

    bool exist(TreeNode* root, int depth, int mid){

        TreeNode* node=root;

        int mod=1<<(depth-1);//从第二高位开始匹配路径，0表示左子树，1表示右子树

        while(node && mod>0){

            if(mid & mod){

                node=node->right;

            }

            else{

                node=node->left;

            }

            mod>>=1;

        }

        return node;

    }

  

    int countNodes(TreeNode* root) {

        if(!root) return 0;

        int depth=0;

        TreeNode* node=root;

        while(node->left){

            depth++;

            node=node->left;

        }

        int l=1<<depth,r=(1<<(depth+1))-1;//二叉树的位运算，如果第 k 个节点位于第 h 层，则 k 的二进制表示包含 h+1 位，其中最高位是 1，其余各位从高到低表示从根节点到第 k 个节点的路径，0 表示移动到左子节点，1 表示移动到右子节点。

        while(l<r){

            int mid=((r-l+1)>>1)+l;

            if(exist(root,depth,mid)){

                l=mid;

            }

            else{

                r=mid-1;

            }

        }

        return l;

    }

};
```

# 110.平衡二叉树

[力扣题目链接](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

![110.平衡二叉树](https://file1.kamacoder.com/i/algo/2021020315542230.png)

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

![110.平衡二叉树1](https://file1.kamacoder.com/i/algo/20210203155447919.png)

返回 false 。

题解：平衡二叉树的定义是左右子节点的高度差<=1

```cpp
class Solution {

public:

    int getHeight(TreeNode* node){

        if(!node){

            return 0;//节点为空则当前节点的高度为0

        }

        int lh=getHeight(node->left);

        if(lh==-1)return -1;

        int rh=getHeight(node->right);

        if(rh==-1)return -1;

        if(abs(rh-lh)<=1) return max(lh,rh)+1;//以该节点为根的二叉树平衡，该节点的高度为子节点的高度+1

        else return -1;

    }

  

    bool isBalanced(TreeNode* root) {

        return getHeight(root)!=-1;//-1表示不平衡，其余值表示节点高度

    }

};
```

# 257. 二叉树的所有路径

[力扣题目链接](https://leetcode.cn/problems/binary-tree-paths/)

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例:  
![257.二叉树的所有路径1](https://file1.kamacoder.com/i/algo/2021020415161576.png)

题解：dfs每条路径即可
```cpp
class Solution {

public:

    void dfs(TreeNode* node, string path, vector<string>& res){

        path+=to_string(node->val);

        if(!(node->left || node->right)) res.push_back(path);

        if(node->left){

            dfs(node->left,path+"->",res);

        }

        if(node->right){

            dfs(node->right,path+"->",res);

        }

    }

    vector<string> binaryTreePaths(TreeNode* root) {

        vector<string> res;

        string path;

        dfs(root,path,res);

        return res;

    }

};
```

# 404.左叶子之和

[力扣题目链接](https://leetcode.cn/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

示例：


![404.左叶子之和1](https://file1.kamacoder.com/i/algo/20210204151927654.png)

题解：
只要判断某一个节点的左子节点是不是叶子节点即可
```cpp
class Solution {

public:

    int sumOfLeftLeaves(TreeNode* root) {

        if(!root) return 0;

        int ls=0,rs=0;

        if(root->left) {

            if(!(root->left->left || root->left->right))

                ls=root->left->val;

            else

                ls=sumOfLeftLeaves(root->left);

        }

        if(root->right) rs=sumOfLeftLeaves(root->right);

        return ls+rs;

    }

};
```


# 513.找树左下角的值

[力扣题目链接](https://leetcode.cn/problems/find-bottom-left-tree-value/)

给定一个二叉树，在树的最后一行找到最左边的值。

示例 1:

![513.找树左下角的值](https://file1.kamacoder.com/i/algo/20210204152956836.png)

示例 2:

![513.找树左下角的值1](https://file1.kamacoder.com/i/algo/20210204153017586.png)

题解：
没啥好说的，按层遍历，保存每层的第一个值即可
```cpp
class Solution {

public:

    int findBottomLeftValue(TreeNode* root) {

        queue<TreeNode*> q;

        q.push(root);

        int res=root->val;

        while(!q.empty()){

            int size=q.size();

            res=q.front()->val;

            while(size--){

                TreeNode* node=q.front();

                q.pop();

                if(node->left) q.push(node->left);

                if(node->right) q.push(node->right);

            }

        }

        return res;

    }

};
```

# 112. 路径总和

[力扣题目链接](https://leetcode.cn/problems/path-sum/)

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例:  
给定如下二叉树，以及目标和 sum = 22，

![](https://file1.kamacoder.com/i/algo/20230407210247.png)

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

题解：
用sum尾递归即可
```cpp
class Solution {

public:

    bool hasPathSum(TreeNode* root, int targetSum) {

        if(!root) return 0;

        if(targetSum==root->val && !(root->left || root->right)) return 1;

        else return hasPathSum(root->left, targetSum-root->val) || hasPathSum(root->right, targetSum-root->val);

    }

};
```

### 113. 路径总和ii

[力扣题目链接](https://leetcode.cn/problems/path-sum-ii/)

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

示例:  
给定如下二叉树，以及目标和 sum = 22，

![113.路径总和ii1.png](https://file1.kamacoder.com/i/algo/20210203160854654.png)

题解：
活用vector的push_back和pop_back

```cpp
class Solution {

public:

    void dfs(TreeNode* root, int targetSum, vector<vector<int>>& res, vector<int>& q){

        if(!root) return;

        q.push_back(root->val);

        if(targetSum==root->val && !root->left && !root->right){

            res.push_back(q);

            q.pop_back();

            return;

        }

        if(root->left) dfs(root->left,targetSum-root->val, res, q);

        if(root->right) dfs(root->right,targetSum-root->val, res, q);

        q.pop_back();

    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {

        vector<vector<int>> res;

        vector<int> q;

        dfs(root,targetSum, res, q);

        return res;

    }

};
```


# 106.从中序与后序遍历序列构造二叉树

[力扣题目链接](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

* 中序遍历 inorder = [9,3,15,20,7]
* 后序遍历 postorder = [9,15,7,20,3]
  返回如下的二叉树：

![106. 从中序与后序遍历序列构造二叉树1](https://file1.kamacoder.com/i/algo/20210203154316774.png)

题解：
### 方法一：迭代
把后序序列和中序序列反过来看
后序序列即使先遍历右子节点的dfs，而中序序列则是表示最右最下节点的遍历
所以可以反向遍历后序序列当作用dfs构建这颗树，通过反向中序序列判断当前节点是否是剩余节点中的最右最下节点
- 如果当前节点不是剩余节点的最右最下节点，则可以继续构建当前这棵树的右子节点分支
- 如果当前节点是最右最下节点，则需要”回溯“到其父节点中没有构建过左子节点的分支。即一直判断当前节点是否是最右最下节点，若是则回溯其父节点，直到当前节点不是最右最下节点为止，为其构建左分支。
- 
```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //posterorder的反向遍历实际上就是先遍历右子节点的先序遍历
        //类似的，inorder的反向遍历实际上就是先遍历右子节点的中序遍历
        //所以，根据反向后续遍历的dfs来构建树，根据反向先序序列来判断当前节点是否是最右最下节点，即dfs是否到底。
        TreeNode* root=new TreeNode(postorder[postorder.size()-1]);
        TreeNode* node=root;
        stack<TreeNode*> q;
        // q.push(root);
        int index_in=inorder.size()-1;
        for(int i=postorder.size()-1;i>=1;i--){
            if(postorder[i]==inorder[index_in]){//postorder[i]是反向后序dfs的当前节点，inorder[index_in]是反向先序序列得到的最右最下节点，即当前节点是最右最下节点，即最右侧分支已经构建完成，现在需要回溯到某一个节点开始构建他的左子树
                index_in--;
                while(!q.empty() && q.top()->val==inorder[index_in]){ 
                    node=q.top();
                    q.pop();
                    index_in--;
                }
                node->left=new TreeNode(postorder[i-1]);
                node=node->left;
            }
            else{
                q.push(node);
                node->right=new TreeNode(postorder[i-1]);
                node=node->right;
            }
        }
        // node->val=postorder[0];
        return root;
    }
};
```

收起

 

迭代

迭代

0/5

### 方法二：递归
同理从按照先序递归根节点，假设当前根节点为x，则可以通过x将中序队列分为两半，一半是x的左子树，一半是x的右子树，值得注意的是。x_index_preorder+1是左子树的根节点，x_index_preorder+sizeof(左子树)+1是右子树的节点。

```cpp
class Solution {
public:
    unordered_map<int, int> index_inorder;

    TreeNode* dfs(vector<int>& inorder, vector<int>& postorder, int l_inorder, int r_inorder, int pos_postorder){
        if(l_inorder>r_inorder){
            return NULL;
        }
        int pos_inorder=index_inorder[postorder[pos_postorder]];
        int size_right=r_inorder-pos_inorder;
        TreeNode* node=new TreeNode(postorder[pos_postorder]);
        node->right=dfs(inorder, postorder, pos_inorder+1, r_inorder, pos_postorder-1);
        node->left=dfs(inorder, postorder, l_inorder, pos_inorder-1, pos_postorder-1-size_right);
        return node;
    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for(int i=0;i<inorder.size();i++){
            index_inorder[inorder[i]]=i;
        }
        return dfs(inorder, postorder, 0, inorder.size()-1, postorder.size()-1);
    }
};
```

### 105.从前序与中序遍历序列构造二叉树

[力扣题目链接](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

![105. 从前序与中序遍历序列构造二叉树](https://file1.kamacoder.com/i/algo/20210203154626672.png)

题解：与106同理，更简单，直接按照左侧dfs就行

### 方法一：迭代
```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        TreeNode* root=new TreeNode(preorder[0]);
        TreeNode* node=root;
        stack<TreeNode*> q;
        int j=0;
        for(int i=0;i<inorder.size()-1;i++){
            if(inorder[j]==preorder[i]){
                j++;
                while(!q.empty() && q.top()->val==inorder[j]){
                    node=q.top();
                    q.pop();
                    j++;
                }
                node->right=new TreeNode(preorder[i+1]);
                node=node->right;
            }
            else{
                node->left=new TreeNode(preorder[i+1]);
                q.push(node);
                node=node->left;
            }
        }
        return root;
    }
};
```



### 方法二：递归
同理从按照先序递归根节点，假设当前根节点为x，则可以通过x将中序队列分为两半，一半是x的左子树，一半是x的右子树，值得注意的是。x_index_preorder+1是左子树的根节点，x_index_preorder+sizeof(左子树)+1是右子树的节点。

```cpp
class Solution {
public:
    unordered_map<int,int> index_inorder;

    TreeNode* dfs(vector<int>& preorder, vector<int>& inorder, int l_inorder, int r_inorder, int pos_preorder){
        if(l_inorder>r_inorder){
            return NULL;
        }
        int pos_inorder=index_inorder[preorder[pos_preorder]];
        int left_size=pos_inorder-l_inorder;
        TreeNode* node=new TreeNode(preorder[pos_preorder]);
        node->left=dfs(preorder, inorder, l_inorder, pos_inorder-1, pos_preorder+1);
        node->right=dfs(preorder, inorder, pos_inorder+1, r_inorder, pos_preorder+left_size+1);
        return node;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for(int i=0;i<inorder.size();i++){
            index_inorder[inorder[i]]=i;
        }
        // TreeNode* root=new TreeNode(preorder[0]);
        return dfs(preorder, inorder, 0, inorder.size()-1, 0);
    }
};
```

# 654.最大二叉树

[力扣题目地址](https://leetcode.cn/problems/maximum-binary-tree/)

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

* 二叉树的根是数组中的最大元素。
* 左子树是通过数组中最大值左边部分构造出的最大二叉树。
* 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

示例 ：

![654.最大二叉树](https://file1.kamacoder.com/i/algo/20210204154534796.png)

提示：

给定的数组的大小在 [1, 1000] 之间。

题解：
### 方法一：递归
```cpp
class Solution {
public:
    TreeNode* buildMaximumBinaryTree(vector<int>& nums, int l, int r) {
        if(l>r)return NULL;
        int pos=l;
        for(int i=l;i<=r;i++){
            if(nums[i]>nums[pos]) pos=i;
        }
        TreeNode* node=new TreeNode(nums[pos]);
        node->left=buildMaximumBinaryTree(nums, l, pos-1);
        node->right=buildMaximumBinaryTree(nums, pos+1, r);
        return node;
    }

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return buildMaximumBinaryTree(nums,0,nums.size()-1);
    }
};
```

### 方法二：单调栈

- 构造两个数组，分别表示i的左边和右边第一个大于nums[i]的数的索引
- i一定是left[i]的右子节点，或者right[i]的左子节点，且在较小的那个值上
证明：若i不是其中的子节点，则在left[i]-right[i]一定存在一个j，且nums[j]>nums[i]，j是left[i]或right[i]的子节点，那么就不满足left[i]和right[i]是左右第一个大于nums[i]的数。假设不成立，所以i一定是他们的子节点。

若i是其中较大值的子节点，则left[i]和right[i]不可能是祖辈关系；left[i]和right[i]必定在一个父节点的左右两个分支上。此时父节点在left[i]和right[i]之间。不符合left[i]和right[i]的定义。所以i一定是较小值的子节点。


```cpp
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        int n=nums.size();
        TreeNode* root=NULL;
        vector<int> left(n,-1);
        vector<int> right(n,-1);
        vector<TreeNode*> trees(n);
        vector<int> q;
        for(int i=0;i<n;i++){
            trees[i] = new TreeNode(nums[i]);
            while(!q.empty() && nums[i]>nums[q.back()]){
                right[q.back()]=i;
                q.pop_back();
            }
            if(!q.empty()){
                left[i]=q.back();
            }
            q.push_back(i);
        }
        for(int i=0;i<n;i++){
            if(left[i]==-1 && right[i]==-1){
                root=trees[i];
            }
            else if(left[i]==-1 || (right[i]!=-1 && nums[left[i]]>nums[right[i]])){
                trees[right[i]]->left=trees[i];
            }
            else{
                trees[left[i]]->right=trees[i];
            }
        }
        return root;
    }
};
```

# 617.合并二叉树

[力扣题目链接](https://leetcode.cn/problems/merge-two-binary-trees/)

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要在·将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:

![617.合并二叉树](https://file1.kamacoder.com/i/algo/20230310000854.png)

注意: 合并必须从两个树的根节点开始。

题解：

```CPP
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
        if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
        // 修改了t1的数值和结构
        t1->val += t2->val;                             // 中
        t1->left = mergeTrees(t1->left, t2->left);      // 左
        t1->right = mergeTrees(t1->right, t2->right);   // 右
        return t1;
    }
};
```

# 700.二叉搜索树中的搜索

[力扣题目地址](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

例如，


![700.二叉搜索树中的搜索](https://file1.kamacoder.com/i/algo/20210204155522476.png)

在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。

题解：
二叉搜索树是一个有序树：

* 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
* 它的左、右子树也分别为二叉搜索树

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        TreeNode* node=root;
        while(node && node->val!=val){
            if(node->val>val) node=node->left;
            else node=node->right;
        }
        return node;
    }
};
```

# 98.验证二叉搜索树

[力扣题目链接](https://leetcode.cn/problems/validate-binary-search-tree/)


给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

* 节点的左子树只包含小于当前节点的数。
* 节点的右子树只包含大于当前节点的数。
* 所有左子树和右子树自身必须也是二叉搜索树。

![98.验证二叉搜索树](https://file1.kamacoder.com/i/algo/20230310000750.png)

题解：
二叉搜索树的中序遍历是单调递增的
用迭代实现
```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        TreeNode* node = root;
        TreeNode* pre = NULL;
        stack<TreeNode*> s;
        while(node || !s.empty()){
            if(node){
                s.push(node);
                node=node->left;
            }
            else{
                node=s.top();
                s.pop();
                if(pre && pre->val>=node->val) return 0;
                pre=node;
                node=node->right;
            }
        }
        return 1;
    }
};
```

# 530.二叉搜索树的最小绝对差

[力扣题目链接](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

示例：

![530二叉搜索树的最小绝对差](https://file1.kamacoder.com/i/algo/20201014223400123.png)

提示：树中至少有 2 个节点。

题解：用中序数列算
用递归实现
```cpp
class Solution {
private:
    int res=INT_MAX;
    TreeNode* pre=NULL;
public:
    void dfs(TreeNode* node){
        if(!node) return;
        dfs(node->left);
        if(pre)
            res=min(res,abs(pre->val-node->val));
        pre=node;
        dfs(node->right);
    }
    int getMinimumDifference(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

# 501.二叉搜索树中的众数


[力扣题目链接](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)


给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

* 结点左子树中所含结点的值小于等于当前结点的值
* 结点右子树中所含结点的值大于等于当前结点的值
* 左子树和右子树都是二叉搜索树

例如：

给定 BST [1,null,2,2],

![501. 二叉搜索树中的众数](https://file1.kamacoder.com/i/algo/20201014221532206.png)

返回[2].

提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

```cpp
int pre=NULL;//不能这样使用，因为int(NULL)==0;
```

```cpp
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        vector<int> res;
        TreeNode* pre=NULL;
        int cnt=1;
        int cnt_z=1;
        TreeNode* node=root;
        stack<TreeNode*> s;
        // queue<int> q;
        while(node || !s.empty()){
            if(node){
                s.push(node);
                node=node->left;
            }
            else{
                node=s.top();
                s.pop();
                if(pre && node->val==pre->val){
                    cnt++;
                }
                else{
                    cnt=1;
                }
                if(cnt>cnt_z){
                    res.clear();
                    res.push_back(pre->val);
                    cnt_z=cnt;
                }
                else if(cnt==cnt_z){
                    res.push_back(node->val);
                }
                pre=node;
                node=node->right;
            }
        }
        return res;
    }
};
```

# 236. 二叉树的最近公共祖先

[力扣题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]


![236. 二叉树的最近公共祖先](https://file1.kamacoder.com/i/algo/20201016173414722.png)

示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

说明:
* 所有节点的值都是唯一的。
* p、q 为不同节点且均存在于给定的二叉树中。

题解：
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root==p || root==q) return root;
        TreeNode* left=lowestCommonAncestor(root->left, p, q);
        TreeNode* right=lowestCommonAncestor(root->right, p, q);
        if(left && right) return root;
        return left?left:right;
    }
};
```

# 235. 二叉搜索树的最近公共祖先

[力扣题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]


![235. 二叉搜索树的最近公共祖先](https://file1.kamacoder.com/i/algo/20201018172243602.png)

示例 1:

* 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
* 输出: 6
* 解释: 节点 2 和节点 8 的最近公共祖先是 6。

示例 2:

* 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
* 输出: 2
* 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。


说明:

* 所有节点的值都是唯一的。
* p、q 为不同节点且均存在于给定的二叉搜索树中。

题解：一共三种情况
1. 都在左子树，则递归左子树
2. 都在右子树，则递归右子树
3. 在两侧，或者当前节点本身就是p或者q，当前节点就是最近父节点

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root==p || root==q) return root;
        if(p->val>root->val && q->val>root->val){
            TreeNode* right=lowestCommonAncestor(root->right, p, q); 
            return right;
        }
        else if(p->val<root->val && q->val<root->val){
            TreeNode* left=lowestCommonAncestor(root->left, p, q);
            return left;
        }
        else{
            return root;
        }
    }
};
```

# 701.二叉搜索树中的插入操作

[力扣题目链接](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。


![701.二叉搜索树中的插入操作](https://file1.kamacoder.com/i/algo/20201019173259554.png)

提示：

* 给定的树上的节点数介于 0 和 10^4 之间
* 每个节点都有一个唯一整数值，取值范围从 0 到 10^8
* -10^8 <= val <= 10^8
* 新值和原始二叉搜索树中的任意节点值都不同

题解：

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            root = new TreeNode(val);
            return root;
        }
        TreeNode* node=root;
        while(node){
            if(val>node->val){
                if(node->right)
                    node=node->right;
                else{
                    node->right=new TreeNode(val);
                    return root;
                }
            }
            else if(val<node->val){
                if(node->left)
                    node=node->left;
                else{
                    node->left=new TreeNode(val);
                    return root;
                }
            }
        }
        return root;
    }
};
```

# ==450.删除二叉搜索树中的节点==

[力扣题目链接]( https://leetcode.cn/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。
说明： 要求算法时间复杂度为 $O(h)$，h 为树的高度。

示例:


![450.删除二叉搜索树中的节点](https://file1.kamacoder.com/i/algo/20201020171048265.png)

题解：
查询目标节点，再确定删除策略

```cpp
class Solution {
public:
    TreeNode* deleteoneNode(TreeNode* root){
        if(!root) return root;
        if(!root->left) return root->right;
        TreeNode* node=root->left;
        while(node->right){
            node=node->right;
        }
        node->right=root->right;
        return root->left;
    }

    TreeNode* deleteNode(TreeNode* root, int key) {
        TreeNode* node=root;
        TreeNode* pre=NULL;
        if(!root) return root;
        
        while(node && node->val!=key){
            pre=node;
            if(key<node->val){
                node=node->left;
            }
            else{
                node=node->right;
            }
        }
        if(!pre){//如果匹配的根节点
            return deleteoneNode(node);
        }
        if(node && node->val<pre->val){
            pre->left=deleteoneNode(node);
        }
        if(node && node->val>pre->val){
            pre->right=deleteoneNode(node);
        }
        
        return root;
    }
};
```


# 669. 修剪二叉搜索树

[力扣题目链接](https://leetcode.cn/problems/trim-a-binary-search-tree/)

给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

![669.修剪二叉搜索树](https://file1.kamacoder.com/i/algo/20201014173115788.png)

![669.修剪二叉搜索树1](https://file1.kamacoder.com/i/algo/20201014173219142.png)

