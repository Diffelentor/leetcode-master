```
struct TreeNode {

      int val;

      TreeNode *left;

      TreeNode *right;

      TreeNode() : val(0), left(nullptr), right(nullptr) {}

      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

  };
```

# 前序、中序、后序遍历

## 递归遍历
```CPP
void inorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}

void preorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}

void postorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

## 迭代遍历

```CPP

vector<int> inorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	TreeNode* cur = root;
	while (cur != NULL || !st.empty()) {
		if (cur != NULL) { // 指针来访问节点，访问到最底层
			st.push(cur); // 将访问的节点放进栈
			cur = cur->left;                // 左
		} else {
			cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
			st.pop();
			result.push_back(cur->val);     // 中
			cur = cur->right;               // 右
		}
	}
	return result;
}

vector<int> preorderTraversal(TreeNode* root) {
	stack<TreeNode*> st;
	vector<int> result;
	if (root == NULL) return result;
	st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();                       // 中
		st.pop();
		result.push_back(node->val);
		if (node->right) st.push(node->right);           // 右（空节点不入栈）
		if (node->left) st.push(node->left);             // 左（空节点不入栈）
	}
	return result;
}

vector<int> postorderTraversal(TreeNode* root) {
	stack<TreeNode*> st;
	vector<int> result;
	if (root == NULL) return result;
	st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		st.pop();
		result.push_back(node->val);
		if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
		if (node->right) st.push(node->right); // 空节点不入栈
	}
	reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
	return result;
}
```


## 迭代遍历（空指针标记法）
```CPP
vector<int> inorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
			if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

			st.push(node);                          // 添加中节点
			st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

			if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
		} else { // 只有遇到空节点的时候，才将下一个节点放进结果集
			st.pop();           // 将空节点弹出
			node = st.top();    // 重新取出栈中元素
			st.pop();
			result.push_back(node->val); // 加入到结果集
		}
	}
	return result;
}

vector<int> preorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop();
			if (node->right) st.push(node->right);  // 右
			if (node->left) st.push(node->left);    // 左
			st.push(node);                          // 中
			st.push(NULL);
		} else {
			st.pop();
			node = st.top();
			st.pop();
			result.push_back(node->val);
		}
	}
	return result;
}

vector<int> postorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop();
			st.push(node);                          // 中
			st.push(NULL);

			if (node->right) st.push(node->right);  // 右
			if (node->left) st.push(node->left);    // 左

		} else {
			st.pop();
			node = st.top();
			st.pop();
			result.push_back(node->val);
		}
	}
	return result;
}
```

# 102.二叉树的层序遍历

[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**题解**：
队列或者递归，但都要标记层数



```CPP
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

```CPP
# 递归法
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth)
    {
        if (cur == nullptr) return;
        if (result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth + 1);
        order(cur->right, result, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

## 107.二叉树的层次遍历 II

[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**题解**：反转数组即可

## 199.二叉树的右视图

[力扣题目链接](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
**题解**：每层返回最后一个数即可

## 637.二叉树的层平均值

[力扣题目链接](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
**题解**：pass

## 429.N叉树的层序遍历

[力扣题目链接](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

**题解**：
```CPP
res.push(move(res_i))\\可以加快速度，但会清空res_i的值，即从复制变为移动（改变指针的所有权）
```

## 515.在每个树行中找最大值

[力扣题目链接](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

您需要在二叉树的每一行中找到最大的值。

**题解**：
无穷大无穷小
```CPP
int maxValue=INT_MIN;

int maxValue=numeric_limits<int>::min();
```

## 116.填充每个节点的下一个右侧节点指针

[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```cpp
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

**题解**：
pass


## 117.填充每个节点的下一个右侧节点指针II

[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

### 思路

这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑一样的味道

## 104.二叉树的最大深度

[力扣题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

## 111.二叉树的最小深度

[力扣题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

# 226.翻转二叉树

[力扣题目链接](https://leetcode.cn/problems/invert-binary-tree/)

翻转一棵二叉树。

**题解**：
按层全部翻转一次即可


# 101. 对称二叉树

[力扣题目链接](https://leetcode.cn/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

```CPP
que.push(leftNode->left);   // 加入左节点左孩子
que.push(rightNode->right); // 加入右节点右孩子
que.push(leftNode->right);  // 加入左节点右孩子
que.push(rightNode->left);  // 加入右节点左孩子
```

* [100.相同的树](https://leetcode.cn/problems/same-tree/)
* [572.另一个树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)
## 572.另一个树的子树

### 方法一：二叉树前序+KMP
```CPP
class Solution {

public:

    void getString(TreeNode* root, vector<int>& rstring, int lNull, int rNull){

        if(!root){

            return;

        }

        else{

            rstring.push_back(root->val);

        }

        if(root->left){

            getString(root->left, rstring, lNull, rNull);

        }

        else{

            rstring.push_back(lNull);

        }

        if(root->right){

            getString(root->right, rstring, lNull, rNull);

        }

        else{

            rstring.push_back(rNull);

        }

  

    }

  

    bool kmp(vector<int> rstring, vector<int> sstring){

        vector<int> next(sstring.size());

        int j=0;

        next[0]=0;

        for(int i=1;i<sstring.size();i++){

            while(j>0 && sstring[j]!=sstring[i]){

                j=next[j-1];//匹配next[j-1]，若j-1和i还是匹配不上再匹配next[j-1]直到能匹配上为止

            }

            if(sstring[j]==sstring[i]){

                j++;

            }

            next[i]=j;//可以从j开始匹配但不确定能不能匹配上，也许j并不能匹配上，但j-1肯定能匹配上

        }

        j=0;

        for(int i=0;i<rstring.size();i++){

            while(j>0 && sstring[j]!=rstring[i]){

                j=next[j-1];

            }

            if(sstring[j]==rstring[i]){

                j++;

            }

            if(j==sstring.size()){

                return true;

            }

        }

        return false;

    }

  

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {

        vector<int> rstring,sstring;

        int lNull=1e4+1,rNull=1e4+2;

        getString(root, rstring, lNull, rNull);

        getString(subRoot, sstring, lNull, rNull);

        for(int i=0;i<rstring.size();i++){

            cout<<rstring[i]<<" ";

        }

        cout<<endl;

        for(int i=0;i<sstring.size();i++){

            cout<<sstring[i]<<" ";

        }

        cout<<endl;

        return kmp(rstring, sstring);

    }

};
```

### 方法二：数哈希匹配
模板（任意树的哈希）
```cpp
#include <bits/stdc++.h>

using namespace std;

  

using ull = unsigned long long;

const ull mask =

mt19937_64(chrono::steady_clock::now().time_since_epoch().count())();

const int MAX_N = 1e6 + 5;

  

ull h[MAX_N];

vector<vector<int>> edge(MAX_N);

set<ull> tree;

  

ull xor_shift(ull x) { // 哈希函数，使用XOR_SHIFT进行哈希，背下来就好

x ^= mask;

x ^= x << 13;

x ^= x >> 7;

x ^= x << 17;

x ^= mask;

return x;

}

  

void gethash(int root, int fa) {

h[root] = 1;

// cout << "当前节点: " << root << endl;

for (int son : edge[root]) {

if (son == fa) {

continue;

}

gethash(son, root);

h[root] += xor_shift(

h[son]); // 哈希的公式是hash[i]=i.val(没有val就用1替代)+sum(hash[i.son])

}

tree.insert(h[root]);

}

  

int main() {

cin.tie(nullptr)->sync_with_stdio(false);

int n, x, y;

cin >> n;

for (int i = 0; i < n - 1; i++) {

cin >> x >> y;

// cout << x << y << endl;

edge[x].push_back(y);

edge[y].push_back(x);

}

// cout << "开始哈希" << endl;

gethash(1, 0);

cout << tree.size();

return 0;

}
```

该题题解：
```cpp
class Solution {

public:

    using ull= unsigned long long;

    const ull mask[2]={mt19937_64(0)(),mt19937_64(1)()};//设计两个mask来应对不同子树的哈希

    vector<ull> h;

    ull shift(ull x, int i){

        x^=mask[i];

        x^=x<<13;

        x^=x>>7;

        x^=x<<17;

        x^=mask[i];

        return x;

    }

  

    ull getHash(TreeNode* root, bool is_root){

        ull hash=shift(root->val,0);//哈希的公式为hash[i]=shift(i.val)(这个shift可不加)+sum(hash[i.sons])

        if(root->left){

            hash+=shift(getHash(root->left, is_root),0);

        }

        if(root->right){

            hash+=shift(getHash(root->right, is_root),1);

        }

        if(is_root) h.push_back(hash);

        return hash;

    }

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {

        getHash(root,1);

        ull subRoot_hash=getHash(subRoot,0);

        for(ull i:h){

            if(subRoot_hash==i)return true;

        }

        return false;

    }

};
```

# 222.完全二叉树的节点个数

[力扣题目链接](https://leetcode.cn/problems/count-complete-tree-nodes/)

给出一个完全二叉树，求出该树的节点个数。

示例 1：
* 输入：root = [1,2,3,4,5,6]
* 输出：6

示例 2：
* 输入：root = []
* 输出：0

示例 3：
* 输入：root = [1]
* 输出：1

提示：

* 树中节点的数目范围是[0, 5 * 10^4]
* 0 <= Node.val <= 5 * 10^4
* 题目数据保证输入的树是 完全二叉树



# 110.平衡二叉树

[力扣题目链接](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

![110.平衡二叉树](https://file1.kamacoder.com/i/algo/2021020315542230.png)

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

![110.平衡二叉树1](https://file1.kamacoder.com/i/algo/20210203155447919.png)

返回 false 。

题解：
如果第 k 个节点位于第 h 层，则 k 的二进制表示包含 h+1 位，其中最高位是 1，其余各位从高到低表示从根节点到第 k 个节点的路径，0 表示移动到左子节点，1 表示移动到右子节点。

然后通过二分法判断最后一层存在的最右边的数

```cpp
class Solution {

public:

    bool exist(TreeNode* root, int depth, int mid){

        TreeNode* node=root;

        int mod=1<<(depth-1);//从第二高位开始匹配路径，0表示左子树，1表示右子树

        while(node && mod>0){

            if(mid & mod){

                node=node->right;

            }

            else{

                node=node->left;

            }

            mod>>=1;

        }

        return node;

    }

  

    int countNodes(TreeNode* root) {

        if(!root) return 0;

        int depth=0;

        TreeNode* node=root;

        while(node->left){

            depth++;

            node=node->left;

        }

        int l=1<<depth,r=(1<<(depth+1))-1;//二叉树的位运算，如果第 k 个节点位于第 h 层，则 k 的二进制表示包含 h+1 位，其中最高位是 1，其余各位从高到低表示从根节点到第 k 个节点的路径，0 表示移动到左子节点，1 表示移动到右子节点。

        while(l<r){

            int mid=((r-l+1)>>1)+l;

            if(exist(root,depth,mid)){

                l=mid;

            }

            else{

                r=mid-1;

            }

        }

        return l;

    }

};
```

# 110.平衡二叉树

[力扣题目链接](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

![110.平衡二叉树](https://file1.kamacoder.com/i/algo/2021020315542230.png)

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

![110.平衡二叉树1](https://file1.kamacoder.com/i/algo/20210203155447919.png)

返回 false 。

题解：平衡二叉树的定义是左右子节点的高度差<=1

```cpp
class Solution {

public:

    int getHeight(TreeNode* node){

        if(!node){

            return 0;//节点为空则当前节点的高度为0

        }

        int lh=getHeight(node->left);

        if(lh==-1)return -1;

        int rh=getHeight(node->right);

        if(rh==-1)return -1;

        if(abs(rh-lh)<=1) return max(lh,rh)+1;//以该节点为根的二叉树平衡，该节点的高度为子节点的高度+1

        else return -1;

    }

  

    bool isBalanced(TreeNode* root) {

        return getHeight(root)!=-1;//-1表示不平衡，其余值表示节点高度

    }

};
```

# 257. 二叉树的所有路径

[力扣题目链接](https://leetcode.cn/problems/binary-tree-paths/)

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例:  
![257.二叉树的所有路径1](https://file1.kamacoder.com/i/algo/2021020415161576.png)

题解：dfs每条路径即可
```cpp
class Solution {

public:

    void dfs(TreeNode* node, string path, vector<string>& res){

        path+=to_string(node->val);

        if(!(node->left || node->right)) res.push_back(path);

        if(node->left){

            dfs(node->left,path+"->",res);

        }

        if(node->right){

            dfs(node->right,path+"->",res);

        }

    }

    vector<string> binaryTreePaths(TreeNode* root) {

        vector<string> res;

        string path;

        dfs(root,path,res);

        return res;

    }

};
```

# 404.左叶子之和

[力扣题目链接](https://leetcode.cn/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

示例：


![404.左叶子之和1](https://file1.kamacoder.com/i/algo/20210204151927654.png)

题解：
只要判断某一个节点的左子节点是不是叶子节点即可
```cpp
class Solution {

public:

    int sumOfLeftLeaves(TreeNode* root) {

        if(!root) return 0;

        int ls=0,rs=0;

        if(root->left) {

            if(!(root->left->left || root->left->right))

                ls=root->left->val;

            else

                ls=sumOfLeftLeaves(root->left);

        }

        if(root->right) rs=sumOfLeftLeaves(root->right);

        return ls+rs;

    }

};
```


# 513.找树左下角的值

[力扣题目链接](https://leetcode.cn/problems/find-bottom-left-tree-value/)

给定一个二叉树，在树的最后一行找到最左边的值。

示例 1:

![513.找树左下角的值](https://file1.kamacoder.com/i/algo/20210204152956836.png)

示例 2:

![513.找树左下角的值1](https://file1.kamacoder.com/i/algo/20210204153017586.png)

题解：
没啥好说的，按层遍历，保存每层的第一个值即可
```cpp
class Solution {

public:

    int findBottomLeftValue(TreeNode* root) {

        queue<TreeNode*> q;

        q.push(root);

        int res=root->val;

        while(!q.empty()){

            int size=q.size();

            res=q.front()->val;

            while(size--){

                TreeNode* node=q.front();

                q.pop();

                if(node->left) q.push(node->left);

                if(node->right) q.push(node->right);

            }

        }

        return res;

    }

};
```

# 112. 路径总和

[力扣题目链接](https://leetcode.cn/problems/path-sum/)

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例:  
给定如下二叉树，以及目标和 sum = 22，

![](https://file1.kamacoder.com/i/algo/20230407210247.png)

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

题解：
用sum尾递归即可
```cpp
class Solution {

public:

    bool hasPathSum(TreeNode* root, int targetSum) {

        if(!root) return 0;

        if(targetSum==root->val && !(root->left || root->right)) return 1;

        else return hasPathSum(root->left, targetSum-root->val) || hasPathSum(root->right, targetSum-root->val);

    }

};
```

### 113. 路径总和ii

[力扣题目链接](https://leetcode.cn/problems/path-sum-ii/)

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

示例:  
给定如下二叉树，以及目标和 sum = 22，

![113.路径总和ii1.png](https://file1.kamacoder.com/i/algo/20210203160854654.png)

题解：
活用vector的push_back和pop_back

```cpp
class Solution {

public:

    void dfs(TreeNode* root, int targetSum, vector<vector<int>>& res, vector<int>& q){

        if(!root) return;

        q.push_back(root->val);

        if(targetSum==root->val && !root->left && !root->right){

            res.push_back(q);

            q.pop_back();

            return;

        }

        if(root->left) dfs(root->left,targetSum-root->val, res, q);

        if(root->right) dfs(root->right,targetSum-root->val, res, q);

        q.pop_back();

    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {

        vector<vector<int>> res;

        vector<int> q;

        dfs(root,targetSum, res, q);

        return res;

    }

};
```


# 106.从中序与后序遍历序列构造二叉树

[力扣题目链接](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

* 中序遍历 inorder = [9,3,15,20,7]
* 后序遍历 postorder = [9,15,7,20,3]
  返回如下的二叉树：

![106. 从中序与后序遍历序列构造二叉树1](https://file1.kamacoder.com/i/algo/20210203154316774.png)

题解：
### 方法一：迭代
把后序序列和中序序列反过来看
后序序列即使先遍历右子节点的dfs，而中序序列则是表示最右最下节点的遍历
所以可以反向遍历后序序列当作用dfs构建这颗树，通过反向中序序列判断当前节点是否是剩余节点中的最右最下节点
- 如果当前节点不是剩余节点的最右最下节点，则可以继续构建当前这棵树的右子节点分支
- 如果当前节点是最右最下节点，则需要”回溯“到其父节点中没有构建过左子节点的分支。即一直判断当前节点是否是最右最下节点，若是则回溯其父节点，直到当前节点不是最右最下节点为止，为其构建左分支。
- 
```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //posterorder的反向遍历实际上就是先遍历右子节点的先序遍历
        //类似的，inorder的反向遍历实际上就是先遍历右子节点的中序遍历
        //所以，根据反向后续遍历的dfs来构建树，根据反向先序序列来判断当前节点是否是最右最下节点，即dfs是否到底。
        TreeNode* root=new TreeNode(postorder[postorder.size()-1]);
        TreeNode* node=root;
        stack<TreeNode*> q;
        // q.push(root);
        int index_in=inorder.size()-1;
        for(int i=postorder.size()-1;i>=1;i--){
            if(postorder[i]==inorder[index_in]){//postorder[i]是反向后序dfs的当前节点，inorder[index_in]是反向先序序列得到的最右最下节点，即当前节点是最右最下节点，即最右侧分支已经构建完成，现在需要回溯到某一个节点开始构建他的左子树
                index_in--;
                while(!q.empty() && q.top()->val==inorder[index_in]){ 
                    node=q.top();
                    q.pop();
                    index_in--;
                }
                node->left=new TreeNode(postorder[i-1]);
                node=node->left;
            }
            else{
                q.push(node);
                node->right=new TreeNode(postorder[i-1]);
                node=node->right;
            }
        }
        // node->val=postorder[0];
        return root;
    }
};
```

收起

 

迭代

迭代

0/5

### 方法二：递归
同理从按照先序递归根节点，假设当前根节点为x，则可以通过x将中序队列分为两半，一半是x的左子树，一半是x的右子树，值得注意的是。x_index_preorder+1是左子树的根节点，x_index_preorder+sizeof(左子树)+1是右子树的节点。

```cpp
class Solution {
public:
    unordered_map<int, int> index_inorder;

    TreeNode* dfs(vector<int>& inorder, vector<int>& postorder, int l_inorder, int r_inorder, int pos_postorder){
        if(l_inorder>r_inorder){
            return NULL;
        }
        int pos_inorder=index_inorder[postorder[pos_postorder]];
        int size_right=r_inorder-pos_inorder;
        TreeNode* node=new TreeNode(postorder[pos_postorder]);
        node->right=dfs(inorder, postorder, pos_inorder+1, r_inorder, pos_postorder-1);
        node->left=dfs(inorder, postorder, l_inorder, pos_inorder-1, pos_postorder-1-size_right);
        return node;
    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        for(int i=0;i<inorder.size();i++){
            index_inorder[inorder[i]]=i;
        }
        return dfs(inorder, postorder, 0, inorder.size()-1, postorder.size()-1);
    }
};
```

### 105.从前序与中序遍历序列构造二叉树

[力扣题目链接](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

![105. 从前序与中序遍历序列构造二叉树](https://file1.kamacoder.com/i/algo/20210203154626672.png)

题解：与106同理，更简单，直接按照左侧dfs就行

### 方法一：迭代
```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        TreeNode* root=new TreeNode(preorder[0]);
        TreeNode* node=root;
        stack<TreeNode*> q;
        int j=0;
        for(int i=0;i<inorder.size()-1;i++){
            if(inorder[j]==preorder[i]){
                j++;
                while(!q.empty() && q.top()->val==inorder[j]){
                    node=q.top();
                    q.pop();
                    j++;
                }
                node->right=new TreeNode(preorder[i+1]);
                node=node->right;
            }
            else{
                node->left=new TreeNode(preorder[i+1]);
                q.push(node);
                node=node->left;
            }
        }
        return root;
    }
};
```



### 方法二：递归
同理从按照先序递归根节点，假设当前根节点为x，则可以通过x将中序队列分为两半，一半是x的左子树，一半是x的右子树，值得注意的是。x_index_preorder+1是左子树的根节点，x_index_preorder+sizeof(左子树)+1是右子树的节点。

```cpp
class Solution {
public:
    unordered_map<int,int> index_inorder;

    TreeNode* dfs(vector<int>& preorder, vector<int>& inorder, int l_inorder, int r_inorder, int pos_preorder){
        if(l_inorder>r_inorder){
            return NULL;
        }
        int pos_inorder=index_inorder[preorder[pos_preorder]];
        int left_size=pos_inorder-l_inorder;
        TreeNode* node=new TreeNode(preorder[pos_preorder]);
        node->left=dfs(preorder, inorder, l_inorder, pos_inorder-1, pos_preorder+1);
        node->right=dfs(preorder, inorder, pos_inorder+1, r_inorder, pos_preorder+left_size+1);
        return node;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for(int i=0;i<inorder.size();i++){
            index_inorder[inorder[i]]=i;
        }
        // TreeNode* root=new TreeNode(preorder[0]);
        return dfs(preorder, inorder, 0, inorder.size()-1, 0);
    }
};
```

# 654.最大二叉树

[力扣题目地址](https://leetcode.cn/problems/maximum-binary-tree/)

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

* 二叉树的根是数组中的最大元素。
* 左子树是通过数组中最大值左边部分构造出的最大二叉树。
* 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

示例 ：

![654.最大二叉树](https://file1.kamacoder.com/i/algo/20210204154534796.png)

提示：

给定的数组的大小在 [1, 1000] 之间。

题解：
### 方法一：递归
```cpp
class Solution {
public:
    TreeNode* buildMaximumBinaryTree(vector<int>& nums, int l, int r) {
        if(l>r)return NULL;
        int pos=l;
        for(int i=l;i<=r;i++){
            if(nums[i]>nums[pos]) pos=i;
        }
        TreeNode* node=new TreeNode(nums[pos]);
        node->left=buildMaximumBinaryTree(nums, l, pos-1);
        node->right=buildMaximumBinaryTree(nums, pos+1, r);
        return node;
    }

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return buildMaximumBinaryTree(nums,0,nums.size()-1);
    }
};
```

### 方法二：单调栈

- 构造两个数组，分别表示i的左边和右边第一个大于nums[i]的数的索引
- i一定是left[i]的右子节点，或者right[i]的左子节点，且在较小的那个值上
证明：若i不是其中的子节点，则在left[i]-right[i]一定存在一个j，且nums[j]>nums[i]，j是left[i]或right[i]的子节点，那么就不满足left[i]和right[i]是左右第一个大于nums[i]的数。假设不成立，所以i一定是他们的子节点。

若i是其中较大值的子节点，则left[i]和right[i]不可能是祖辈关系；left[i]和right[i]必定在一个父节点的左右两个分支上。此时父节点在left[i]和right[i]之间。不符合left[i]和right[i]的定义。所以i一定是较小值的子节点。


```cpp
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        int n=nums.size();
        TreeNode* root=NULL;
        vector<int> left(n,-1);
        vector<int> right(n,-1);
        vector<TreeNode*> trees(n);
        vector<int> q;
        for(int i=0;i<n;i++){
            trees[i] = new TreeNode(nums[i]);
            while(!q.empty() && nums[i]>nums[q.back()]){
                right[q.back()]=i;
                q.pop_back();
            }
            if(!q.empty()){
                left[i]=q.back();
            }
            q.push_back(i);
        }
        for(int i=0;i<n;i++){
            if(left[i]==-1 && right[i]==-1){
                root=trees[i];
            }
            else if(left[i]==-1 || (right[i]!=-1 && nums[left[i]]>nums[right[i]])){
                trees[right[i]]->left=trees[i];
            }
            else{
                trees[left[i]]->right=trees[i];
            }
        }
        return root;
    }
};
```