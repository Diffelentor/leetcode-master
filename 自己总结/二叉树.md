```
struct TreeNode {

      int val;

      TreeNode *left;

      TreeNode *right;

      TreeNode() : val(0), left(nullptr), right(nullptr) {}

      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

  };
```

# 前序、中序、后序遍历

## 递归遍历
```CPP
void inorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}

void preorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}

void postorder(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

## 迭代遍历

```CPP

vector<int> inorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	TreeNode* cur = root;
	while (cur != NULL || !st.empty()) {
		if (cur != NULL) { // 指针来访问节点，访问到最底层
			st.push(cur); // 将访问的节点放进栈
			cur = cur->left;                // 左
		} else {
			cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
			st.pop();
			result.push_back(cur->val);     // 中
			cur = cur->right;               // 右
		}
	}
	return result;
}

vector<int> preorderTraversal(TreeNode* root) {
	stack<TreeNode*> st;
	vector<int> result;
	if (root == NULL) return result;
	st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();                       // 中
		st.pop();
		result.push_back(node->val);
		if (node->right) st.push(node->right);           // 右（空节点不入栈）
		if (node->left) st.push(node->left);             // 左（空节点不入栈）
	}
	return result;
}

vector<int> postorderTraversal(TreeNode* root) {
	stack<TreeNode*> st;
	vector<int> result;
	if (root == NULL) return result;
	st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		st.pop();
		result.push_back(node->val);
		if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
		if (node->right) st.push(node->right); // 空节点不入栈
	}
	reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
	return result;
}
```


## 迭代遍历（空指针标记法）
```CPP
vector<int> inorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
			if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

			st.push(node);                          // 添加中节点
			st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

			if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
		} else { // 只有遇到空节点的时候，才将下一个节点放进结果集
			st.pop();           // 将空节点弹出
			node = st.top();    // 重新取出栈中元素
			st.pop();
			result.push_back(node->val); // 加入到结果集
		}
	}
	return result;
}

vector<int> preorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop();
			if (node->right) st.push(node->right);  // 右
			if (node->left) st.push(node->left);    // 左
			st.push(node);                          // 中
			st.push(NULL);
		} else {
			st.pop();
			node = st.top();
			st.pop();
			result.push_back(node->val);
		}
	}
	return result;
}

vector<int> postorderTraversal(TreeNode* root) {
	vector<int> result;
	stack<TreeNode*> st;
	if (root != NULL) st.push(root);
	while (!st.empty()) {
		TreeNode* node = st.top();
		if (node != NULL) {
			st.pop();
			st.push(node);                          // 中
			st.push(NULL);

			if (node->right) st.push(node->right);  // 右
			if (node->left) st.push(node->left);    // 左

		} else {
			st.pop();
			node = st.top();
			st.pop();
			result.push_back(node->val);
		}
	}
	return result;
}
```

# 102.二叉树的层序遍历

[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**题解**：
队列或者递归，但都要标记层数



```CPP
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

```CPP
# 递归法
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth)
    {
        if (cur == nullptr) return;
        if (result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth + 1);
        order(cur->right, result, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

## 107.二叉树的层次遍历 II

[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**题解**：反转数组即可

## 199.二叉树的右视图

[力扣题目链接](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
**题解**：每层返回最后一个数即可

## 637.二叉树的层平均值

[力扣题目链接](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
**题解**：pass

## 429.N叉树的层序遍历

[力扣题目链接](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

**题解**：
```CPP
res.push(move(res_i))\\可以加快速度，但会清空res_i的值，即从复制变为移动（改变指针的所有权）
```

## 515.在每个树行中找最大值

[力扣题目链接](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

您需要在二叉树的每一行中找到最大的值。

**题解**：
无穷大无穷小
```CPP
int maxValue=INT_MIN;

int maxValue=numeric_limits<int>::min();
```

## 116.填充每个节点的下一个右侧节点指针

[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```cpp
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

**题解**：
pass


## 117.填充每个节点的下一个右侧节点指针II

[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

### 思路

这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑一样的味道

## 104.二叉树的最大深度

[力扣题目链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

## 111.二叉树的最小深度

[力扣题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

# 226.翻转二叉树

[力扣题目链接](https://leetcode.cn/problems/invert-binary-tree/)

翻转一棵二叉树。

**题解**：
按层全部翻转一次即可


# 101. 对称二叉树

[力扣题目链接](https://leetcode.cn/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

```CPP
que.push(leftNode->left);   // 加入左节点左孩子
que.push(rightNode->right); // 加入右节点右孩子
que.push(leftNode->right);  // 加入左节点右孩子
que.push(rightNode->left);  // 加入右节点左孩子
```

* [100.相同的树](https://leetcode.cn/problems/same-tree/)
* [572.另一个树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)
## 572.另一个树的子树

### 方法一：二叉树前序+KMP
```CPP
class Solution {

public:

    void getString(TreeNode* root, vector<int>& rstring, int lNull, int rNull){

        if(!root){

            return;

        }

        else{

            rstring.push_back(root->val);

        }

        if(root->left){

            getString(root->left, rstring, lNull, rNull);

        }

        else{

            rstring.push_back(lNull);

        }

        if(root->right){

            getString(root->right, rstring, lNull, rNull);

        }

        else{

            rstring.push_back(rNull);

        }

  

    }

  

    bool kmp(vector<int> rstring, vector<int> sstring){

        vector<int> next(sstring.size());

        int j=0;

        next[0]=0;

        for(int i=1;i<sstring.size();i++){

            while(j>0 && sstring[j]!=sstring[i]){

                j=next[j-1];//匹配next[j-1]，若j-1和i还是匹配不上再匹配next[j-1]直到能匹配上为止

            }

            if(sstring[j]==sstring[i]){

                j++;

            }

            next[i]=j;//可以从j开始匹配但不确定能不能匹配上，也许j并不能匹配上，但j-1肯定能匹配上

        }

        j=0;

        for(int i=0;i<rstring.size();i++){

            while(j>0 && sstring[j]!=rstring[i]){

                j=next[j-1];

            }

            if(sstring[j]==rstring[i]){

                j++;

            }

            if(j==sstring.size()){

                return true;

            }

        }

        return false;

    }

  

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {

        vector<int> rstring,sstring;

        int lNull=1e4+1,rNull=1e4+2;

        getString(root, rstring, lNull, rNull);

        getString(subRoot, sstring, lNull, rNull);

        for(int i=0;i<rstring.size();i++){

            cout<<rstring[i]<<" ";

        }

        cout<<endl;

        for(int i=0;i<sstring.size();i++){

            cout<<sstring[i]<<" ";

        }

        cout<<endl;

        return kmp(rstring, sstring);

    }

};
```

### 方法二：数哈希匹配
模板（任意树的哈希）
```cpp
#include <bits/stdc++.h>

using namespace std;

  

using ull = unsigned long long;

const ull mask =

mt19937_64(chrono::steady_clock::now().time_since_epoch().count())();

const int MAX_N = 1e6 + 5;

  

ull h[MAX_N];

vector<vector<int>> edge(MAX_N);

set<ull> tree;

  

ull xor_shift(ull x) { // 哈希函数，使用XOR_SHIFT进行哈希，背下来就好

x ^= mask;

x ^= x << 13;

x ^= x >> 7;

x ^= x << 17;

x ^= mask;

return x;

}

  

void gethash(int root, int fa) {

h[root] = 1;

// cout << "当前节点: " << root << endl;

for (int son : edge[root]) {

if (son == fa) {

continue;

}

gethash(son, root);

h[root] += xor_shift(

h[son]); // 哈希的公式是hash[i]=i.val(没有val就用1替代)+sum(hash[i.son])

}

tree.insert(h[root]);

}

  

int main() {

cin.tie(nullptr)->sync_with_stdio(false);

int n, x, y;

cin >> n;

for (int i = 0; i < n - 1; i++) {

cin >> x >> y;

// cout << x << y << endl;

edge[x].push_back(y);

edge[y].push_back(x);

}

// cout << "开始哈希" << endl;

gethash(1, 0);

cout << tree.size();

return 0;

}
```

该题题解：
```cpp
class Solution {

public:

    using ull= unsigned long long;

    const ull mask[2]={mt19937_64(0)(),mt19937_64(1)()};//设计两个mask来应对不同子树的哈希

    vector<ull> h;

    ull shift(ull x, int i){

        x^=mask[i];

        x^=x<<13;

        x^=x>>7;

        x^=x<<17;

        x^=mask[i];

        return x;

    }

  

    ull getHash(TreeNode* root, bool is_root){

        ull hash=shift(root->val,0);//哈希的公式为hash[i]=shift(i.val)(这个shift可不加)+sum(hash[i.sons])

        if(root->left){

            hash+=shift(getHash(root->left, is_root),0);

        }

        if(root->right){

            hash+=shift(getHash(root->right, is_root),1);

        }

        if(is_root) h.push_back(hash);

        return hash;

    }

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {

        getHash(root,1);

        ull subRoot_hash=getHash(subRoot,0);

        for(ull i:h){

            if(subRoot_hash==i)return true;

        }

        return false;

    }

};
```

# 222.完全二叉树的节点个数

[力扣题目链接](https://leetcode.cn/problems/count-complete-tree-nodes/)

给出一个完全二叉树，求出该树的节点个数。

示例 1：
* 输入：root = [1,2,3,4,5,6]
* 输出：6

示例 2：
* 输入：root = []
* 输出：0

示例 3：
* 输入：root = [1]
* 输出：1

提示：

* 树中节点的数目范围是[0, 5 * 10^4]
* 0 <= Node.val <= 5 * 10^4
* 题目数据保证输入的树是 完全二叉树



# 110.平衡二叉树

[力扣题目链接](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

![110.平衡二叉树](https://file1.kamacoder.com/i/algo/2021020315542230.png)

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

![110.平衡二叉树1](https://file1.kamacoder.com/i/algo/20210203155447919.png)

返回 false 。

题解：
如果第 k 个节点位于第 h 层，则 k 的二进制表示包含 h+1 位，其中最高位是 1，其余各位从高到低表示从根节点到第 k 个节点的路径，0 表示移动到左子节点，1 表示移动到右子节点。

然后通过二分法判断最后一层存在的最右边的数

```cpp
class Solution {

public:

    bool exist(TreeNode* root, int depth, int mid){

        TreeNode* node=root;

        int mod=1<<(depth-1);//从第二高位开始匹配路径，0表示左子树，1表示右子树

        while(node && mod>0){

            if(mid & mod){

                node=node->right;

            }

            else{

                node=node->left;

            }

            mod>>=1;

        }

        return node;

    }

  

    int countNodes(TreeNode* root) {

        if(!root) return 0;

        int depth=0;

        TreeNode* node=root;

        while(node->left){

            depth++;

            node=node->left;

        }

        int l=1<<depth,r=(1<<(depth+1))-1;//二叉树的位运算，如果第 k 个节点位于第 h 层，则 k 的二进制表示包含 h+1 位，其中最高位是 1，其余各位从高到低表示从根节点到第 k 个节点的路径，0 表示移动到左子节点，1 表示移动到右子节点。

        while(l<r){

            int mid=((r-l+1)>>1)+l;

            if(exist(root,depth,mid)){

                l=mid;

            }

            else{

                r=mid-1;

            }

        }

        return l;

    }

};
```

# 110.平衡二叉树

[力扣题目链接](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

![110.平衡二叉树](https://file1.kamacoder.com/i/algo/2021020315542230.png)

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

![110.平衡二叉树1](https://file1.kamacoder.com/i/algo/20210203155447919.png)

返回 false 。

题解：平衡二叉树的定义是左右子节点的高度差<=1

```cpp
class Solution {

public:

    int getHeight(TreeNode* node){

        if(!node){

            return 0;//节点为空则当前节点的高度为0

        }

        int lh=getHeight(node->left);

        if(lh==-1)return -1;

        int rh=getHeight(node->right);

        if(rh==-1)return -1;

        if(abs(rh-lh)<=1) return max(lh,rh)+1;//以该节点为根的二叉树平衡，该节点的高度为子节点的高度+1

        else return -1;

    }

  

    bool isBalanced(TreeNode* root) {

        return getHeight(root)!=-1;//-1表示不平衡，其余值表示节点高度

    }

};
```

# 257. 二叉树的所有路径

[力扣题目链接](https://leetcode.cn/problems/binary-tree-paths/)

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例:  
![257.二叉树的所有路径1](https://file1.kamacoder.com/i/algo/2021020415161576.png)

题解：dfs每条路径即可
```cpp
class Solution {

public:

    void dfs(TreeNode* node, string path, vector<string>& res){

        path+=to_string(node->val);

        if(!(node->left || node->right)) res.push_back(path);

        if(node->left){

            dfs(node->left,path+"->",res);

        }

        if(node->right){

            dfs(node->right,path+"->",res);

        }

    }

    vector<string> binaryTreePaths(TreeNode* root) {

        vector<string> res;

        string path;

        dfs(root,path,res);

        return res;

    }

};
```

# 404.左叶子之和

[力扣题目链接](https://leetcode.cn/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

示例：


![404.左叶子之和1](https://file1.kamacoder.com/i/algo/20210204151927654.png)

题解：
只要判断某一个节点的左子节点是不是叶子节点即可
```cpp
class Solution {

public:

    int sumOfLeftLeaves(TreeNode* root) {

        if(!root) return 0;

        int ls=0,rs=0;

        if(root->left) {

            if(!(root->left->left || root->left->right))

                ls=root->left->val;

            else

                ls=sumOfLeftLeaves(root->left);

        }

        if(root->right) rs=sumOfLeftLeaves(root->right);

        return ls+rs;

    }

};
```


# 513.找树左下角的值

[力扣题目链接](https://leetcode.cn/problems/find-bottom-left-tree-value/)

给定一个二叉树，在树的最后一行找到最左边的值。

示例 1:

![513.找树左下角的值](https://file1.kamacoder.com/i/algo/20210204152956836.png)

示例 2:

![513.找树左下角的值1](https://file1.kamacoder.com/i/algo/20210204153017586.png)

题解：
没啥好说的，按层遍历，保存每层的第一个值即可
```cpp
class Solution {

public:

    int findBottomLeftValue(TreeNode* root) {

        queue<TreeNode*> q;

        q.push(root);

        int res=root->val;

        while(!q.empty()){

            int size=q.size();

            res=q.front()->val;

            while(size--){

                TreeNode* node=q.front();

                q.pop();

                if(node->left) q.push(node->left);

                if(node->right) q.push(node->right);

            }

        }

        return res;

    }

};
```

# 112. 路径总和

[力扣题目链接](https://leetcode.cn/problems/path-sum/)

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例:  
给定如下二叉树，以及目标和 sum = 22，

![](https://file1.kamacoder.com/i/algo/20230407210247.png)

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

题解：
用sum尾递归即可
```cpp
class Solution {

public:

    bool hasPathSum(TreeNode* root, int targetSum) {

        if(!root) return 0;

        if(targetSum==root->val && !(root->left || root->right)) return 1;

        else return hasPathSum(root->left, targetSum-root->val) || hasPathSum(root->right, targetSum-root->val);

    }

};
```

### 113. 路径总和ii

[力扣题目链接](https://leetcode.cn/problems/path-sum-ii/)

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

示例:  
给定如下二叉树，以及目标和 sum = 22，

![113.路径总和ii1.png](https://file1.kamacoder.com/i/algo/20210203160854654.png)

题解：
活用vector的push_back和pop_back

```cpp
class Solution {

public:

    void dfs(TreeNode* root, int targetSum, vector<vector<int>>& res, vector<int>& q){

        if(!root) return;

        q.push_back(root->val);

        if(targetSum==root->val && !root->left && !root->right){

            res.push_back(q);

            q.pop_back();

            return;

        }

        if(root->left) dfs(root->left,targetSum-root->val, res, q);

        if(root->right) dfs(root->right,targetSum-root->val, res, q);

        q.pop_back();

    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {

        vector<vector<int>> res;

        vector<int> q;

        dfs(root,targetSum, res, q);

        return res;

    }

};
```


# 106.从中序与后序遍历序列构造二叉树

[力扣题目链接](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

* 中序遍历 inorder = [9,3,15,20,7]
* 后序遍历 postorder = [9,15,7,20,3]
  返回如下的二叉树：

![106. 从中序与后序遍历序列构造二叉树1](https://file1.kamacoder.com/i/algo/20210203154316774.png)

题解：
