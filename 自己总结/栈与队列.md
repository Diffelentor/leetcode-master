# 232.用栈实现队列

[力扣题目链接](https://leetcode.cn/problems/implement-queue-using-stacks/)

使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。     
pop() -- 从队列首部移除元素。    
peek() -- 返回队列首部的元素。    
empty() -- 返回队列是否为空。   


示例:

```cpp
MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
```

说明:

* 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
* 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
* 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。

**题解**：
申明两个栈S1和S2分别做入栈和出栈用，在S1为空时需将S1全部出栈后压栈到S2，其余情况正常。

# 225. 用队列实现栈

[力扣题目链接](https://leetcode.cn/problems/implement-stack-using-queues/)

使用队列实现栈的下列操作：

* push(x) -- 元素 x 入栈
* pop() -- 移除栈顶元素
* top() -- 获取栈顶元素
* empty() -- 返回栈是否为空

注意:

* 你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
* 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
* 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

**题解**：
pass

# 20. 有效的括号

[力扣题目链接](https://leetcode.cn/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。
- 注意空字符串可被认为是有效字符串。

示例 1:

- 输入: "()"
- 输出: true

示例 2:

- 输入: "()[]{}"
- 输出: true

示例 3:

- 输入: "(]"
- 输出: false

示例 4:

- 输入: "([)]"
- 输出: false

示例 5:

- 输入: "{[]}"
- 输出: true

**题解**：
用栈匹配即可
小技巧：判断左括号后压栈右括号以方便后续匹配

# 1047. 删除字符串中的所有相邻重复项

[力扣题目链接](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。


示例：
* 输入："abbaca"
* 输出："ca"
* 解释：例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。


提示：
* 1 <= S.length <= 20000
* S 仅由小写英文字母组成。

**题解**：利用栈先入后出的特性，用栈顶判断临近字母是否相同即可

# 150. 逆波兰表达式求值

[力扣题目链接](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

根据 逆波兰表示法，求表达式的值。

有效的运算符包括 + ,  - ,  *  ,  / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。


示例 1：
* 输入: ["2", "1", "+", "3", " * "]
* 输出: 9
* 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

示例 2：
* 输入: ["4", "13", "5", "/", "+"]
* 输出: 6
* 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

示例 3：
* 输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]

* 输出: 22

* 解释:该算式转化为常见的中缀算术表达式为：

  ```
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5       
  = ((10 * (6 / (12 * -11))) + 17) + 5       
  = ((10 * (6 / -132)) + 17) + 5     
  = ((10 * 0) + 17) + 5     
  = (0 + 17) + 5    
  = 17 + 5    
  = 22    
  ```


逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。

该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点：

* 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。

* 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。

**题解**：
用栈来做即可
考虑string转int的两种方式
stoi(str)
atoi(str.c_str())

stoi、stoll、stod可是实现string转in、longlong、double


# 239. 滑动窗口最大值

[力扣题目链接](https://leetcode.cn/problems/sliding-window-maximum/)

给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

进阶：

你能在线性时间复杂度内解决此题吗？

<img src='https://file1.kamacoder.com/i/algo/239.滑动窗口最大值.png' width=600> </img></div>

提示：

* 1 <= nums.length <= 10^5
* -10^4 <= nums[i] <= 10^4
* 1 <= k <= nums.length

**题解**：

维护一个单调不增的序列以保证里面有可能的最大值
当窗口向右移动时，若在窗口内左侧的数小于右侧的数，则左侧的数一定不可能成为最大值；相对的在左侧的数离开窗口，右侧的数即使很小也可能成为最大值。

```
class Solution {

public:

    class MyQueue{

    public:

        deque<int> q;

        MyQueue(){}

        void pop(int t){

            if(!q.empty()&&t==q.front()){

                q.pop_front();

            }

        }

        void push(int t){

            while(!q.empty()&&q.back()<t){

                q.pop_back();

            }

            q.push_back(t);

        }

        int front(){

            return q.front();

        }

    };

    vector<int> maxSlidingWindow(vector<int>& nums, int k) {

        vector<int> res;

        MyQueue q;

        for(int i=0;i<k;i++){

            q.push(nums[i]);

        }

        res.push_back(q.front());

        for(int i=1;i<nums.size()-k+1;i++){

            // if(nums[i-1]==q.front()){

            //     q.pop();

            // }

            q.pop(nums[i-1]);

            q.push(nums[i+k-1]);

            res.push_back(q.front());

        }

        return res;

    }

};
```

# 347.前 K 个高频元素

[力扣题目链接](https://leetcode.cn/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

示例 1:
* 输入: nums = [1,1,1,2,2,3], k = 2
* 输出: [1,2]

示例 2:
* 输入: nums = [1], k = 1
* 输出: [1]

提示：
* 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
* 你的算法的时间复杂度必须优于 $O(n \log n)$ , n 是数组的大小。
* 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
* 你可以按任意顺序返回答案。

**题解**：
注意优先队列的用法，包括申明、自定义比较函数、无法使用容器索引（例如 pq.begin()）

```
class Solution {

public:

    class cmp{

    public:

        bool operator ()(const pair<int,int>& a, const pair<int,int>& b){

            return a.second>b.second;

        }

    };//推荐写法，仿函数

  

    vector<int> topKFrequent(vector<int>& nums, int k) {

        priority_queue<pair<int,int>,vector<pair<int,int> > ,cmp> q;

        unordered_map<int,int> m;

        for(int& i:nums){

            m[i]++;

        }

        for(auto& i:m){

            q.push(pair<int,int>(i.first,i.second));

            // q.emplace(i.first,i.second);

            if(q.size()>k)q.pop();

        }

        vector<int> res;

        while(!q.empty()){

            res.push_back(q.top().first);

            q.pop();

        }

        return res;

    }

};
```

